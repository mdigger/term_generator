//+build ignore

package main

import (
	"bytes"
	"errors"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/Masterminds/sprig"
	"github.com/jackc/tern/migrate"
)

const (
	blobFileName string = "data.go"
	embedFolder  string = "../../migrations"
)

func main() {
	log.SetFlags(log.Lmsgprefix)
	if _, err := os.Stat(embedFolder); os.IsNotExist(err) {
		log.Fatal("Migrations directory does not exists!")
	}
	// загружаем и разбираем файлы с миграциями
	migrations, err := LoadMigrations(embedFolder)
	if err != nil {
		log.Fatal("Error loading migration files:", err)
	}
	// создаем файл, в который будут встроены скрипты миграции
	f, err := os.Create(blobFileName)
	if err != nil {
		log.Fatal("Error creating blob file:", err)
	}
	defer f.Close()
	// записываем в файл информацию со скриптами миграции
	io.WriteString(f, `package db

// Code generated by go generate; DO NOT EDIT.

import "github.com/jackc/tern/migrate"

func init() {
	migrations = []*migrate.Migration{
`)
	for _, m := range migrations {
		fmt.Fprintf(f, "\t\t{\n\t\t\tSequence: %d,\n\t\t\tName:     %q,\n\t\t\tUpSQL:    %q,\n\t\t\tDownSQL:  %q,\n\t\t},\n",
			m.Sequence, m.Name, m.UpSQL, m.DownSQL)
	}
	io.WriteString(f, "\t}\n}\n")
}

// код скопирован и немного изменен из https://github.com/jackc/tern/migrate

type loader struct {
	Migrations []*migrate.Migration
	Data       map[string]interface{} // Data available to use in migrations
}

func (l *loader) evalMigration(tmpl *template.Template, sql string) (string, error) {
	tmpl, err := tmpl.Parse(sql)
	if err != nil {
		return "", err
	}
	var buf bytes.Buffer
	err = tmpl.Execute(&buf, l.Data)
	if err != nil {
		return "", err
	}
	return buf.String(), nil
}

func (l *loader) appendMigration(name, upSQL, downSQL string) {
	l.Migrations = append(
		l.Migrations,
		&migrate.Migration{
			Sequence: int32(len(l.Migrations)) + 1,
			Name:     name,
			UpSQL:    upSQL,
			DownSQL:  downSQL,
		})
	return
}

// LoadMigrations загружает и разбирает файлы с миграциями.
func LoadMigrations(path string) ([]*migrate.Migration, error) {
	var loader = &loader{
		Migrations: make([]*migrate.Migration, 0),
		Data:       make(map[string]interface{}),
	}
	path = strings.TrimRight(path, string(filepath.Separator))
	mainTmpl := template.New("main").Funcs(sprig.TxtFuncMap()).Funcs(
		template.FuncMap{
			"install_snapshot": func(name string) (string, error) {
				codePackage, err := loadCodePackage(filepath.Join(path, "snapshots", name))
				if err != nil {
					return "", err
				}
				return codePackage.Eval(loader.Data)
			},
		},
	)
	sharedPaths, err := filepath.Glob(filepath.Join(path, "*", "*.sql"))
	if err != nil {
		return nil, err
	}
	for _, p := range sharedPaths {
		body, err := ioutil.ReadFile(p) // #nosec G304
		if err != nil {
			return nil, err
		}
		name := strings.Replace(p, path+string(filepath.Separator), "", 1)
		_, err = mainTmpl.New(name).Parse(string(body))
		if err != nil {
			return nil, err
		}
	}
	paths, err := migrate.FindMigrations(path)
	if err != nil {
		return nil, err
	}
	if len(paths) == 0 {
		return nil, migrate.NoMigrationsFoundError{Path: path}
	}
	for _, p := range paths {
		body, err := ioutil.ReadFile(p) // #nosec G304
		if err != nil {
			return nil, err
		}
		pieces := strings.SplitN(string(body), "---- create above / drop below ----", 2)
		var upSQL, downSQL string
		upSQL = strings.TrimSpace(pieces[0])
		upSQL, err = loader.evalMigration(mainTmpl.New(filepath.Base(p)+" up"), upSQL)
		if err != nil {
			return nil, err
		}
		// Make sure there is SQL in the forward migration step.
		containsSQL := false
		for _, v := range strings.Split(upSQL, "\n") {
			// Only account for regular single line comment, empty line and space/comment combination
			cleanString := strings.TrimSpace(v)
			if len(cleanString) != 0 &&
				!strings.HasPrefix(cleanString, "--") {
				containsSQL = true
				break
			}
		}
		if !containsSQL {
			return nil, migrate.ErrNoFwMigration
		}

		if len(pieces) == 2 {
			downSQL = strings.TrimSpace(pieces[1])
			downSQL, err = loader.evalMigration(mainTmpl.New(filepath.Base(p)+" down"), downSQL)
			if err != nil {
				return nil, err
			}
		}
		loader.appendMigration(filepath.Base(p), upSQL, downSQL)
	}
	return loader.Migrations, nil
}

type codePackage struct {
	tmpl *template.Template
}

func (cp *codePackage) Eval(data map[string]interface{}) (string, error) {
	buf := &bytes.Buffer{}
	err := cp.tmpl.Lookup("install.sql").Execute(buf, data)
	if err != nil {
		return "", err
	}

	return buf.String(), nil
}

func loadCodePackage(path string) (*codePackage, error) {
	path = strings.TrimRight(path, string(filepath.Separator))
	mainTmpl := template.New("main").Funcs(sprig.TxtFuncMap())
	sqlPaths, err := findCodeFiles(path)
	if err != nil {
		return nil, err
	}
	for _, p := range sqlPaths {
		body, err := ioutil.ReadFile(p) // #nosec G304
		if err != nil {
			return nil, err
		}
		name := strings.Replace(p, path+string(filepath.Separator), "", 1)
		_, err = mainTmpl.New(name).Parse(string(body))
		if err != nil {
			return nil, err
		}
	}
	installTmpl := mainTmpl.Lookup("install.sql")
	if installTmpl == nil {
		return nil, errors.New("install.sql not found")
	}
	codePackage := &codePackage{tmpl: mainTmpl}
	return codePackage, nil
}

func findCodeFiles(dirname string) ([]string, error) {
	dirname = strings.TrimRight(dirname, string(filepath.Separator))
	entries, err := ioutil.ReadDir(dirname)
	if err != nil {
		return nil, err
	}
	var results []string
	for _, e := range entries {
		ePath := filepath.Join(dirname, e.Name())
		if e.IsDir() {
			paths, err := findCodeFiles(ePath)
			if err != nil {
				return nil, err
			}
			results = append(results, paths...)
		} else {
			match, err := filepath.Match("*.sql", e.Name())
			if err != nil {
				return nil, fmt.Errorf("impossible filepath.Match error %w", err)
			}
			if match {
				results = append(results, ePath)
			}
		}
	}
	return results, nil
}
